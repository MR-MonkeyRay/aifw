name: aifw-release

on:
  push:
    branches:
      - '**'
  release:
    types: [created]
  workflow_dispatch:
    inputs:
      build_docker:
        description: 'Build Docker images'
        required: false
        default: false
        type: boolean

jobs:
  create-tag:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    permissions:
      contents: write
    outputs:
      version: ${{ steps.tag.outputs.version }}
      tag_created: ${{ steps.tag.outputs.tag_created }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Configure Git
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"

    - name: Extract version and create tag
      id: tag
      run: |
        # 尝试从多个位置提取版本号
        VERSION=""

        # 1. 尝试从 cli/python/services/app/__init__.py 提取
        if [ -f "cli/python/services/app/__init__.py" ]; then
          VERSION=$(grep -oP '__version__\s*=\s*"\K[^"]+' cli/python/services/app/__init__.py || true)
        fi

        # 2. 如果没找到，尝试从 py-origin/services/app/__init__.py 提取
        if [[ -z "$VERSION" ]] && [ -f "py-origin/services/app/__init__.py" ]; then
          VERSION=$(grep -oP '__version__\s*=\s*"\K[^"]+' py-origin/services/app/__init__.py || true)
        fi

        # 3. 如果还是没找到，使用日期版本号
        if [[ -z "$VERSION" ]]; then
          VERSION="0.1.$(date +%Y%m%d)"
          echo "::warning::No version found in source files, using date-based version: $VERSION"
        fi

        echo "Current version: $VERSION"
        echo "version=$VERSION" >> $GITHUB_OUTPUT

        # 检查 tag 是否已存在
        if git tag -l "v$VERSION" | grep -q "v$VERSION"; then
          echo "::warning::Tag v$VERSION already exists, skipping tag creation"
          echo "tag_created=false" >> $GITHUB_OUTPUT
          exit 0
        fi

        # 创建并推送 tag
        echo "Creating tag v$VERSION"
        git tag "v$VERSION"
        git push origin "v$VERSION"
        echo "tag_created=true" >> $GITHUB_OUTPUT
        echo "Successfully created and pushed tag v$VERSION"

  aifw-js-package:
    if: github.event_name == 'release' || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Enable Corepack
        run: corepack enable

      - name: Activate pnpm 8.15.4
        run: corepack prepare pnpm@8.15.4 --activate

      - name: Setup Rust (stable + wasm32 target)
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: wasm32-unknown-unknown

      - name: Install Zig
        uses: mlugg/setup-zig@v2
        with:
          version: 0.15.2
          use-cache: true

      - name: Build Zig core
        run: zig build

      - name: Install dependencies
        run: pnpm -w install

      - name: Build aifw-js (without models and ORT WASM)
        env:
          AIFW_SKIP_MODELS: '1'
          AIFW_SKIP_ORT_WASM: '1'
        run: pnpm -w --filter @oneaifw/aifw-js build

      - name: Create release package
        run: |
          cd libs/aifw-js/dist
          # Get version from release tag or ref name
          if [ "${{ github.event_name }}" == "release" ]; then
            VERSION="${{ github.event.release.tag_name }}"
          else
            VERSION=$(echo "${{ github.ref_name }}" | sed 's|/|-|g')
          fi
          # Remove 'v' prefix if present
          VERSION="${VERSION#v}"
          PACKAGE_NAME="aifw-js-${VERSION}"
          mkdir -p ../../../release-packages
          tar -czf "../../../release-packages/${PACKAGE_NAME}.tar.gz" .
          echo "Package created: release-packages/${PACKAGE_NAME}.tar.gz"
          ls -lh ../../../release-packages/

      - name: Upload release package
        uses: actions/upload-artifact@v4
        with:
          name: aifw-js-package
          path: release-packages/*.tar.gz
          retention-days: 90

      - name: Upload to release (if release event)
        if: github.event_name == 'release'
        uses: softprops/action-gh-release@v2
        with:
          files: release-packages/*.tar.gz
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  docker-amd64:
    # Run on push events, or if explicitly requested:
    # - workflow_dispatch: inputs.build_docker == true
    # - release: release title/body contains explicit opt-in markers
    #   (any of: 'build_docker=true', 'docker: true', or title contains '[docker]')
    runs-on: ubuntu-latest
    needs: [create-tag]
    if: |
      always() &&
      (needs.create-tag.result == 'success' || needs.create-tag.result == 'skipped') &&
      (
        github.event_name == 'push' ||
        (github.event_name == 'workflow_dispatch' && inputs.build_docker == true) ||
        (github.event_name == 'release' && (
          contains(github.event.release.body, 'build_docker=true') ||
          contains(github.event.release.body, 'docker: true') ||
          contains(github.event.release.name, '[docker]')
        ))
      )
    timeout-minutes: 600
    permissions:
      contents: read
      packages: write
    env:
      DO_HARBOR: ${{ secrets.HARBOR_USERNAME != '' && secrets.HARBOR_PASSWORD != '' }}
      DO_DOCKERHUB: ${{ secrets.DOCKERHUB_USERNAME != '' && secrets.DOCKERHUB_TOKEN != '' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Rust (stable + wasm32 target)
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: wasm32-unknown-unknown

      - name: Install Zig
        uses: mlugg/setup-zig@v2
        with:
          version: 0.15.2
          use-cache: true

      - name: Build Zig core native library (amd64)
        run: zig build -Doptimize=ReleaseFast -Dtarget=x86_64-linux-gnu -Dcpu=haswell

      - name: Generate safe ref tag
        id: ref_tag
        run: echo "tag=$(echo '${{ github.ref_name }}' | sed 's|/|-|g')" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Log in to Docker Hub
        if: env.DO_DOCKERHUB == 'true'
        uses: docker/login-action@v3
        with:
          registry: docker.io
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Extract metadata (amd64)
        id: meta_amd64
        uses: docker/metadata-action@v5
        with:
          images: |
            ghcr.io/${{ github.repository_owner }}/oneaifw
            ${{ env.DO_DOCKERHUB == 'true' && format('docker.io/{0}/oneaifw', secrets.DOCKERHUB_USERNAME) || '' }}
          flavor: |
            suffix=-amd64
          tags: |
            type=ref,event=tag
            type=ref,event=branch
            type=raw,value=latest
            type=sha,format=short

      - name: Build and push backend (amd64)
        uses: docker/build-push-action@v6
        with:
          context: .
          file: cli/python/Dockerfile
          push: true
          platforms: linux/amd64
          cache-from: type=gha
          cache-to: type=gha,mode=max
          tags: ${{ steps.meta_amd64.outputs.tags }}
          labels: ${{ steps.meta_amd64.outputs.labels }}

      - name: Build and push web (amd64)
        uses: docker/build-push-action@v6
        with:
          context: .
          file: web/Dockerfile
          push: true
          platforms: linux/amd64
          build-args: |
            SPACY_PROFILE=minimal
          tags: |
            ghcr.io/${{ github.repository_owner }}/oneaifw-web:${{ steps.ref_tag.outputs.tag }}-amd64
            ghcr.io/${{ github.repository_owner }}/oneaifw-web:latest-amd64
          labels: |
            org.opencontainers.image.title=OneAIFW Web
            org.opencontainers.image.description=AI Framework Web Interface
            org.opencontainers.image.version=${{ steps.ref_tag.outputs.tag }}
            org.opencontainers.image.created=${{ github.event.repository.updated_at || github.event.head_commit.timestamp }}
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}

      # Harbor push with registry cache (action cache on your own server)
      - name: Login to Harbor
        if: env.DO_HARBOR == 'true'
        uses: docker/login-action@v3
        with:
          registry: registry.cn-shanghai.aliyuncs.com
          username: ${{ secrets.HARBOR_USERNAME }}
          password: ${{ secrets.HARBOR_PASSWORD }}

      - name: Build and push to Harbor web with registry cache (amd64)
        if: env.DO_HARBOR == 'true'
        uses: docker/build-push-action@v6
        with:
          context: .
          file: web/Dockerfile
          push: true
          platforms: linux/amd64
          tags: |
            registry.cn-shanghai.aliyuncs.com/immtranslate/oneaifw:${{ github.sha }}-amd64
            registry.cn-shanghai.aliyuncs.com/immtranslate/oneaifw:latest-amd64
          cache-from: type=gha
          cache-to: type=gha,mode=max

  docker-arm64:
    # Run on push events, or if explicitly requested:
    # - workflow_dispatch: inputs.build_docker == true
    # - release: release title/body contains explicit opt-in markers
    #   (any of: 'build_docker=true', 'docker: true', or title contains '[docker]')
    runs-on: ubuntu-24.04-arm
    needs: [create-tag]
    if: |
      always() &&
      (needs.create-tag.result == 'success' || needs.create-tag.result == 'skipped') &&
      (
        github.event_name == 'push' ||
        (github.event_name == 'workflow_dispatch' && inputs.build_docker == true) ||
        (github.event_name == 'release' && (
          contains(github.event.release.body, 'build_docker=true') ||
          contains(github.event.release.body, 'docker: true') ||
          contains(github.event.release.name, '[docker]')
        ))
      )
    timeout-minutes: 600
    permissions:
      contents: read
      packages: write
    env:
      DO_HARBOR: ${{ secrets.HARBOR_USERNAME != '' && secrets.HARBOR_PASSWORD != '' }}
      DO_DOCKERHUB: ${{ secrets.DOCKERHUB_USERNAME != '' && secrets.DOCKERHUB_TOKEN != '' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Rust (stable + wasm32 target)
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: wasm32-unknown-unknown

      - name: Install Zig
        uses: mlugg/setup-zig@v2
        with:
          version: 0.15.2
          use-cache: true

      - name: Build Zig core native library (arm64)
        run: zig build -Doptimize=ReleaseFast

      - name: Generate safe ref tag
        id: ref_tag
        run: echo "tag=$(echo '${{ github.ref_name }}' | sed 's|/|-|g')" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Log in to Docker Hub
        if: env.DO_DOCKERHUB == 'true'
        uses: docker/login-action@v3
        with:
          registry: docker.io
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Extract metadata (arm64)
        id: meta_arm64
        uses: docker/metadata-action@v5
        with:
          images: |
            ghcr.io/${{ github.repository_owner }}/oneaifw
            ${{ env.DO_DOCKERHUB == 'true' && format('docker.io/{0}/oneaifw', secrets.DOCKERHUB_USERNAME) || '' }}
          flavor: |
            suffix=-arm64
          tags: |
            type=ref,event=tag
            type=ref,event=branch
            type=raw,value=latest
            type=sha,format=short

      - name: Build and push backend (arm64)
        uses: docker/build-push-action@v6
        with:
          context: .
          file: cli/python/Dockerfile
          push: true
          platforms: linux/arm64
          cache-from: type=gha
          cache-to: type=gha,mode=max
          tags: ${{ steps.meta_arm64.outputs.tags }}
          labels: ${{ steps.meta_arm64.outputs.labels }}

      - name: Build and push web (arm64)
        uses: docker/build-push-action@v6
        with:
          context: .
          file: web/Dockerfile
          push: true
          platforms: linux/arm64
          build-args: |
            SPACY_PROFILE=minimal
          tags: |
            ghcr.io/${{ github.repository_owner }}/oneaifw-web:${{ steps.ref_tag.outputs.tag }}-arm64
            ghcr.io/${{ github.repository_owner }}/oneaifw-web:latest-arm64
          labels: |
            org.opencontainers.image.title=OneAIFW Web
            org.opencontainers.image.description=AI Framework Web Interface
            org.opencontainers.image.version=${{ steps.ref_tag.outputs.tag }}
            org.opencontainers.image.created=${{ github.event.repository.updated_at || github.event.head_commit.timestamp }}
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}

      # Harbor push with registry cache (action cache on your own server)
      - name: Login to Harbor
        if: env.DO_HARBOR == 'true'
        uses: docker/login-action@v3
        with:
          registry: registry.cn-shanghai.aliyuncs.com
          username: ${{ secrets.HARBOR_USERNAME }}
          password: ${{ secrets.HARBOR_PASSWORD }}

      - name: Build and push to Harbor web with registry cache (arm64)
        if: env.DO_HARBOR == 'true'
        uses: docker/build-push-action@v6
        with:
          context: .
          file: web/Dockerfile
          push: true
          platforms: linux/arm64
          tags: |
            registry.cn-shanghai.aliyuncs.com/immtranslate/oneaifw:${{ github.sha }}-arm64
            registry.cn-shanghai.aliyuncs.com/immtranslate/oneaifw:latest-arm64
          cache-from: type=gha
          cache-to: type=gha,mode=max

  docker-merge:
    runs-on: ubuntu-latest
    needs: [docker-amd64, docker-arm64]
    if: |
      always() &&
      needs.docker-amd64.result == 'success' &&
      needs.docker-arm64.result == 'success'
    permissions:
      contents: read
      packages: write
    env:
      DO_HARBOR: ${{ secrets.HARBOR_USERNAME != '' && secrets.HARBOR_PASSWORD != '' }}
      DO_DOCKERHUB: ${{ secrets.DOCKERHUB_USERNAME != '' && secrets.DOCKERHUB_TOKEN != '' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Log in to Docker Hub
        if: env.DO_DOCKERHUB == 'true'
        uses: docker/login-action@v3
        with:
          registry: docker.io
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Extract metadata (canonical)
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository_owner }}/oneaifw
          tags: |
            type=ref,event=tag
            type=ref,event=branch
            type=raw,value=latest
            type=sha,format=short

      - name: Create multi-arch manifest (backend, GHCR)
        run: |
          echo "${{ steps.meta.outputs.tags }}" | while read -r tag; do
            [ -z "$tag" ] && continue
            docker buildx imagetools create \
              -t "$tag" \
              "${tag}-amd64" \
              "${tag}-arm64"
          done

      - name: Create multi-arch manifest (backend, DockerHub)
        if: env.DO_DOCKERHUB == 'true'
        run: |
          REF_TAG=$(echo "${{ github.ref_name }}" | sed 's|/|-|g')
          for t in "${REF_TAG}" latest; do
            docker buildx imagetools create \
              -t "docker.io/${{ secrets.DOCKERHUB_USERNAME }}/oneaifw:${t}" \
              "docker.io/${{ secrets.DOCKERHUB_USERNAME }}/oneaifw:${t}-amd64" \
              "docker.io/${{ secrets.DOCKERHUB_USERNAME }}/oneaifw:${t}-arm64"
          done

      - name: Create multi-arch manifest (web, GHCR)
        run: |
          REF_TAG=$(echo "${{ github.ref_name }}" | sed 's|/|-|g')
          for t in "${REF_TAG}" latest; do
            docker buildx imagetools create \
              -t "ghcr.io/${{ github.repository_owner }}/oneaifw-web:${t}" \
              "ghcr.io/${{ github.repository_owner }}/oneaifw-web:${t}-amd64" \
              "ghcr.io/${{ github.repository_owner }}/oneaifw-web:${t}-arm64"
          done

      # Harbor: create multi-arch manifests if enabled
      - name: Login to Harbor
        if: env.DO_HARBOR == 'true'
        uses: docker/login-action@v3
        with:
          registry: registry.cn-shanghai.aliyuncs.com
          username: ${{ secrets.HARBOR_USERNAME }}
          password: ${{ secrets.HARBOR_PASSWORD }}

      - name: Create multi-arch manifest (web, Harbor)
        if: env.DO_HARBOR == 'true'
        run: |
          for t in "${GITHUB_SHA}" latest; do
            docker buildx imagetools create \
              -t "registry.cn-shanghai.aliyuncs.com/immtranslate/oneaifw:${t}" \
              "registry.cn-shanghai.aliyuncs.com/immtranslate/oneaifw:${t}-amd64" \
              "registry.cn-shanghai.aliyuncs.com/immtranslate/oneaifw:${t}-arm64"
          done

      - name: Start fake LLM (echo) on runner
        run: |
          cd py-origin
          python -m pip install --upgrade pip
          pip install fastapi uvicorn pydantic
          python -m uvicorn services.fake_llm.echo_server:app --host 0.0.0.0 --port 8801 &
          echo $! > echo_llm.pid
          for i in $(seq 1 20); do curl -sf http://127.0.0.1:8801/v1/health && break || sleep 0.5; done

      - name: Prepare OpenAI-compatible docker key file (host.docker.internal)
        run: |
          # This file points to the fake LLM running on the runner host.
          # Inside Docker, 127.0.0.1 refers to the container itself, so we use
          # host.docker.internal (mapped via --add-host below) to reach the host.
          cat > $RUNNER_TEMP/echo-apikey-docker.json << 'JSON'
          {
            "openai-api-key": "test-local-echo",
            "openai-base-url": "http://host.docker.internal:8801/v1",
            "openai-model": "echo-001"
          }
          JSON

      - name: Normal test container (launch → call → stop)
        run: |
          PROMPT="请把如下文本翻译为中文: My email address is test@example.com, and my phone number is 18744325579."
          # Map host.docker.internal to host gateway so the container can reach the fake LLM on the runner
          docker run --rm \
            --add-host=host.docker.internal:host-gateway \
            -e AIFW_API_KEY_FILE=/data/aifw/echo.json \
            -v $RUNNER_TEMP/echo-apikey-docker.json:/data/aifw/echo.json \
            ghcr.io/${{ github.repository_owner }}/oneaifw:latest \
            sh -lc '
              aifw launch --log-dest stdout &
              for i in $(seq 1 40); do curl -sf http://127.0.0.1:8844/api/health && break || sleep 0.5; done
              aifw call "$PROMPT"
              aifw stop'

      - name: Normal test container (direct_call)
        run: |
          PROMPT="请把如下文本翻译为中文: My email address is test@example.com, and my phone number is 18744325579."
          # Map host.docker.internal to host gateway so the container can reach the fake LLM on the runner
          docker run --rm \
            --add-host=host.docker.internal:host-gateway \
            -e AIFW_API_KEY_FILE=/data/aifw/echo.json \
            -v $RUNNER_TEMP/echo-apikey-docker.json:/data/aifw/echo.json \
            ghcr.io/${{ github.repository_owner }}/oneaifw:latest \
            sh -lc 'aifw direct_call "$PROMPT"'

      - name: Teardown fake LLM
        if: always()
        run: |
          if [ -f echo_llm.pid ]; then kill $(cat echo_llm.pid) || true; fi

